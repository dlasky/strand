<link rel="import" href="bitmask.html">
<script>
/**
 * @license
 * Copyright (c) 2015 MediaMath Inc. All rights reserved.
 * This code may only be used under the BSD style license found at http://mediamath.github.io/strand/LICENSE.txt

*/
(function (scope) {

	function Rectangle (x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	}

	Rectangle.fromElement = function(element) {
		if (element && element.getBoundingClientRect) {
			var cr = element.getBoundingClientRect();
			return new Rectangle(cr.left, cr.top, cr.width, cr.height);
		} else {
			return new Rectangle(0,0,0,0);
		}
	};

	// force the inverse of the overlap into the channel portion of the mask
	// (only if the overlap is not "both" or "neither")
	Rectangle.fixBits = function (align, overlap, channel, mode) {
		overlap = overlap & channel;
		var center = align & Rectangle.SIDE.CENTER,
			vcenter = align & Rectangle.SIDE.VCENTER;
		if (center || vcenter) {
			if (overlap) {
				align |= overlap ^ channel;
				if (vcenter) align &= ~Rectangle.SIDE.VCENTER;
				if (center) align &= ~Rectangle.SIDE.CENTER;
			}
		} else if ((overlap & channel) !== 0 && (overlap & channel) !== channel) {
			align = (align & ~channel) | (align ^ channel);
		}
		return align;
	};

	Rectangle.SIDE = new scope.BitMask("TOP","BOTTOM","LEFT","RIGHT","CENTER","VCENTER");

	Rectangle.prototype = {

		get left() { return this.x; },
		set left(i) { this.x = i; },

		get right() { return this.x + this.width;},
		set right(i) { this.x = i - this.width; },

		get top () { return this.y; },
		set top (i) { this.y = i; },

		get bottom () { return this.y + this.height; },
		set bottom (i) { this.y = i - this.height; },

		get center() { return this.x + this.width/2; },
		set center(i) { this.x = i - this.width/2; },

		get vcenter() {return this.y + this.height/2; },
		set vcenter(i) { this.y = i - this.height/2; },

		clone: function() {
			return new Rectangle(this.x, this.y, this.width, this.height);
		},

		outside : function (other) {
			var bitfield = 0,
				r = Rectangle.SIDE;
			(this.left < other.left) && (bitfield |= r.LEFT);
			(this.right > other.right) && (bitfield |= r.RIGHT);
			(this.top < other.top) && (bitfield |= r.TOP);
			(this.bottom > other.bottom) && (bitfield |= r.BOTTOM);
			return bitfield;
		},

		toCSS : function(element,exact) {
			if (element && element.style) {
				if(exact) {
					element.style.left = this.left + "px";
					element.style.top = this.top + "px";					
				} else {
					element.style.left = Math.round(this.left) + "px";
					element.style.top = Math.round(this.top) + "px";
				}
			}
			return this;
		},

		toCanvas: function(ctx) {
			ctx.beginPath();
			ctx.moveTo(this.top, this.left);
			ctx.lineTo(this.top, this.right);
			ctx.lineTo(this.bottom, this.right);
			ctx.lineTo(this.bottom, this.left);
			ctx.lineTo(this.top, this.left);
			ctx.stroke();
		},

		toCanvasRounded: function(context, radius) {
			context.beginPath();
			context.moveTo(this.x+radius, this.top);
			context.lineTo(this.right-radius, this.top);
			context.quadraticCurveTo(this.right, this.top, this.right, this.top+radius);
			context.lineTo(this.right, this.bottom-radius);
			context.quadraticCurveTo(this.right, this.bottom, this.right-radius, this.bottom);
			context.lineTo(this.left+radius, this.bottom);
			context.quadraticCurveTo(this.left, this.bottom, this.left, this.bottom-radius);
			context.lineTo(this.left, this.top+radius);
			context.quadraticCurveTo(this.left, this.top, this.left+radius, this.top);
			context.stroke();
		},

		positionRelative : function(other, mask) {
			var r = Rectangle.SIDE;
			(r.LEFT & mask) && (this.right = other.left);
			(r.RIGHT & mask) && (this.left = other.right);
			(r.TOP & mask) && (this.bottom = other.top);
			(r.BOTTOM & mask) && (this.top = other.bottom);
			(r.CENTER & mask) && (this.center = other.center);
			(r.VCENTER & mask) && (this.vcenter = other.vcenter);
			return this;
		},

		subtract: function(other) {
			this.x -= other.x;
			this.y -= other.y;
		},

		flipV: function() {
			this.y = -this.y;
		},

		flipH: function() {
			this.x = -this.x;
		},

		alignRelative : function(other, mask) {
			var r = Rectangle.SIDE;
			(r.LEFT & mask) && (this.left = other.left);
			(r.RIGHT & mask) && (this.right = other.right);
			(r.TOP & mask) && (this.bottom = other.bottom);
			(r.BOTTOM & mask) && (this.top = other.top);
			(r.CENTER & mask) && (this.center = other.center);
			(r.VCENTER & mask) && (this.vcenter = other.vcenter);
			
			return this;
		}
	};

	scope.Rectangle = Rectangle;
})(window.StrandLib = window.StrandLib || {}); 
</script>
